Voxel Garden
============

Also on https://voxel-garden.sornas.dev !

Compilation Instructions
------------------------

You only need to install Rust and its build system Cargo. We have developed on
Arch Linux, where everything we need is available in the `rust` package.
Lately, more distributions have started packaging Rust (and sometimes Cargo in
a separate package), but as they may be out of date (sometimes severly), using
https://rustup.rs (which installs everything for your local user) is probably
easiest. Follow the instructions on https://rustup.rs.

With Rust and Cargo installed, `cargo run --release --locked` should be enough
to compile and run. `--release` is equivalent to `-O2` and `--locked` tells
Cargo to use the `Cargo.lock` file which tracks the exact version of
dependencies used during development.

Usage Instructions
------------------

Move around with WASD and mouse. We didn't manage to lock the mouse to the
screen but you can at least press F1 to toggle controlling the camera if you
want to play with the sliders.

Code Structure
--------------

This section will quickly mention how the code is structured.

The program entry point is located in src/main.rs. miniquad handles the main
loop, so we have a struct App that contains all program state and our functions
for update/draw. miniquad calls these functions once per frame, first update
and then draw. We also define different event handlers that are called by
miniquad on I/O events (for example, 'key_down_event').

As mentioned, the App struct contains all program state. This includes the
obvious stuff, such as which keys are pressed down and the changeable uniforms,
but also our GlContext which is used to communicate with OpenGL.

Terrain generation
~~~~~~~~~~~~~~~~~~

The directory src/models contains code for biomes, terrain, flowers, trees and
rocks. They are split into one file each and can be read fairly stand-alone.

Flowers, trees and rocks are all handled similarly. We have defined functions
that takes as parameter a _translation_, which is the position of the "base" of
the model, and returns one or more Models. The Model struct itself is defined in
src/models/mod.rs.

Biomes are described in src/models/biomes.rs. Given a BiomeConfig, we can
sample the biome Perlin noise with the get_biome function, which takes as
parameters a coordinate and returns the biome at that point. Each biome has a
corresponding BiomeSpawnData which defines what can be spawned in that biome
and the probability of it spawning. We can then call get_spawn_type with the
same coordinate which tells us if we should spawn anything at that coordinate.

Finally, src/models/terrain.rs wraps it all together. The function
generate_terrain is called once for each chunk that is generated. It iterates
over every (x, z)-coordinate in the chunk and checks the biome and if a
flower/tree/rock should be spawned. It also checks the water level.

Rendering
~~~~~~~~~

The code for the rendering is located in src/rendering/mod.rs.

The new() function compiles the shaders, uploads the cube model that is used to
draw everything, creates the random texture used by the water shader code and
creates an empty buffer for the instance data.

The vertex and fragment shader are located in src/rendering/shader.{frag,vert}.
They are compiled into the program binary, meaning you only have to distribute
the binary itself to run the project.

The function draw_voxels is used to draw voxels to the screen (no way!). It
copies the instance data to the GPU, updates the uniforms and performs a draw
call. It is called from the draw_chunk_and_around function src/main.rs, which
draws the chunk the camera is currently located in and render_distance chunks
in either direction. For each chunk that is drawn, we start by drawing the
ground, followed by all the models with its base in that chunk.

In order to not block the main thread when generating new terrain, we have a
separate thread for that. In draw_chunk_and_around, if a chunk is to be drawn
but it hasn't been yet, the chunk coordinate is sent through a channel to the
terrain thread. For thread safety, the terrain is locked by a Mutex.

Debug sliders
~~~~~~~~~~~~~

The debug windows are generated by a library called egui which has a miniquad
integration. The relevant code is in src/main.rs (function egui_ui) and
src/rendering/mod.rs (function egui_uniform_slider_rows). It is also possible
to compile without the egui stuff by passing --no-default-features to the Cargo
commands. Without egui, the final binary size drops from 3.9M to 699K!
